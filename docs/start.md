# 入门
## 示例

代码(demo.cc)：

```c++
#include <stdio.h>
#include <stdlib.h>

void sum(int a, int b) {
  int c = a + b;
  printf("%d + %d = ?\n", a, b);
  printf("%d\n", c);
}

int main(int argc, char* argv[]) {
  int a = atoi(argv[1]);
  int b = atoi(argv[2]);
  sum(a, b);
  return 0;
}
```

编译和运行： 

```she
$ g++ -o demo -Wall -g demo.cc
$ ./demo
段错误 (core dumped)
```



## 调试

常用启动方式有如下三种：

* gdb 可执行文件 CORE文件
* gdb 可执行文件 进程ID
* gdb --args  可执行文件 可执行文件的运行参数1 参数2 。。。

我们使用第一种方式启动：

```shell
$ gdb demo core.27813
GNU gdb (GDB) Red Hat Enterprise Linux 8.2-3.el7
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from demo...done.
[New LWP 27813]
Core was generated by `./demo'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  __GI_____strtol_l_internal (nptr=0x0, endptr=endptr@entry=0x0, base=base@entry=10, group=group@entry=0, loc=0x7ff120bab060 <_nl_global_locale>) at ../stdlib/strtol_l.c:298
298	  while (ISSPACE (*s))
(gdb)
```

上述输出会显示如下几个部分：

1. gdb的版权声明和一些帮助信息；

2. 读入调试符号信息，对应于上文g++编译时候的`-g`参数，如果不加该参数编译，则gdb启动时显示`Reading symbols from demo...(no debugging symbols found)...done.`。这意味着我们使用gdb调试时只能看到对应的指令和地址，却因为没有调试的符号信息无法将其和对应的源码的位置关联起来。
3. Core文件的生成信息和终止信号，此处为`SIGSEGV`，即最常见的崩溃：段错误或者Segment fault。
4. 最后一项也是最重要的，显示的是当崩溃发生时所处的调用堆栈的栈帧信息，其中`#0`代表当前崩溃的栈帧，`#1`则是调用者栈帧，以此类推。

使用`bt`命令可以查看完整的调用栈：

```shell
(gdb) bt
#0  __GI_____strtol_l_internal (nptr=0x0, endptr=endptr@entry=0x0, base=base@entry=10, group=group@entry=0, loc=0x7ff120bab060 <_nl_global_locale>) at ../stdlib/strtol_l.c:298
#1  0x00007ff120826cf2 in __GI_strtol (nptr=<optimized out>, endptr=endptr@entry=0x0, base=base@entry=10) at ../stdlib/strtol.c:109
#2  0x00007ff120823770 in atoi (nptr=<optimized out>) at atoi.c:27
#3  0x00000000004005eb in main (argc=1, argv=0x7ffc145e5a08) at demo.cc:11
```

使用`f`命令可以切换到`#3`即`main`函数栈帧中，这也是唯一和`demo.cc`相关的栈帧。

```shell
(gdb) f 3
#3  0x00000000004005eb in main (argc=1, argv=0x7ffc145e5a08) at demo.cc:11
11	  int a = atoi(argv[1]);
```

通过查看上述栈帧内容可知是传递`argv[1]`参数给`atoi`函数导致的崩溃。故推测`argv[1]`的内容可能不合法。使用`p`命令打印`argv[1]`进行验证：

```shell
(gdb) p argv[1]
$1 = 0x0
(gdb) p *(argv+1)
$2 = 0x0
```

*注：上述两种打印方式等价，后续我们均采用`arg+N`的形式，主要是考虑到C++语言中该符号被重载。*

根据输出可知，`argv[1]`为空指针：`0x0`。

我们继续深入，看看空指针在`atoi`函数内部究竟是如何传递和使用的。

使用`f`命令逐一跟踪`#3`、`#2`、`#1`和`#0`，并在`#0`栈帧执行`l`命令显示更多的源码内容：

```shell
(gdb) f 3
#3  0x00000000004005eb in main (argc=1, argv=0x7ffc145e5a08) at demo.cc:11
11	  int a = atoi(argv[1]);
(gdb) f 2
#2  0x00007ff120823770 in atoi (nptr=<optimized out>) at atoi.c:27
27	  return (int) strtol (nptr, (char **) NULL, 10);
(gdb) f 1
#1  0x00007ff120826cf2 in __GI_strtol (nptr=<optimized out>, endptr=endptr@entry=0x0, base=base@entry=10) at ../stdlib/strtol.c:109
109	  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, _NL_CURRENT_LOCALE);
(gdb) f 0
#0  __GI_____strtol_l_internal (nptr=0x0, endptr=endptr@entry=0x0, base=base@entry=10, group=group@entry=0, loc=0x7ff120bab060 <_nl_global_locale>) at ../stdlib/strtol_l.c:298
298	  while (ISSPACE (*s))
(gdb) l
293	    }
294
295	  save = s = nptr;
296
297	  /* Skip white space.  */
298	  while (ISSPACE (*s))
299	    ++s;
```

根据输出我们可以得到完整的函数调用链：`main` -> `atoi` -> `strtol` -> `INTERNAL (__strtol_l)`。

*这里稍作解释：* 

*`INTERNAL`为宏定义`__##X##_internal`，展开即为：`____strtol_l_internal`。输出中的前缀`__GI_`，可以理解为是给函数起的别名。如`__GI_strtol`是`strtol`的别名，而`__GI_____strtol_l_internal`是`_____strtol_l_internal`的别名。关于别名的原理可参见gcc的string_alias和weak_alias机制。*

通过对上述输出进行分析，可以得出引起崩溃的原因：

值为`0x00`的变量`argv[1]`被从`main`层层传递到`__GI_____strtol_l_internal`，并作为参数`nptr`的值，在`strtol_l.c:295`处将`nptr`又赋值给变量`s`，并尝试在`strtol_l.c:298`处访问空指针`s`所指的内容。正是这个读取空指针内容的操作引起了崩溃。

综上可知，由于程序启动时没有设置必要的参数，导致`argv[1]`为空指针，最终引发了程序崩溃。



## 一些问题

#### 1. 源码包缺失

对于调试过程中调用glibc的`atoi`、`printf`和其他函数时候，为保证gdb可以看到这些库函数的源码，需要安装glibc的源码包。如果缺失源码包时。使用gdb会提示如：`Missing separate debuginfos, use: debuginfo-install ...`。照着提示安装即可。比如上述stdlib/strtol_l.c如果未安装源码包时，就无法通过`l`命令看到相应的源码信息。

如果是Debian系统，可以通过命令：`sudo apt install glibc-source`安装源码包，默认安装位置：

`/usr/src/glibc/glibc-2.28.tar.xz`。再将解压后的源码路径配置到gdb的全局配置文件`gdbinit`（或者当前用户`.gdbinit`）中，如下：

```shell
cat /etc/gdb/gdbinit 
# System-wide GDB initialization file.
directory /usr/src/glibc/glibc-2.28/stdio-common:/usr/src/glibc/glibc-2.28/malloc
```

#### 2. 查看core文件信息

对于目录下存在多个core文件的情况下进行调试时，必须保证可执行文件和coredump文件相匹配，即该core文件必须是由待调试的可执行文件生成的。可通过如下方式判断：

```shell
$ file core.27813
core.27813: ELF 64-bit LSB core file x86-64, version 1 (SYSV), SVR4-style, from './demo'
```

#### 3. 没有生成core文件

使用`ulimit`命令查看是否允许生成core文件

```shel
$ ulimit -a
core file size          (blocks, -c) unlimited
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
......
```

确保core file size的值为unlimited而不是0。

另，查看`/proc/sys/kernel/core_pattern`文件，可以定位到具体core文件位置，默认为当前目录。